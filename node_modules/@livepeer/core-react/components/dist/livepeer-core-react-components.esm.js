import * as React from 'react';
import { d as useMemoizedIcon, c as useConditionalIcon, a as useCreateAsset, b as usePlaybackInfo } from '../../dist/system-f1ea33f2.esm.js';
import { parseCid, parseArweaveTxId, isNumber } from '@livepeer/core/utils';
import { getMediaSourceType } from '@livepeer/core';
import '@livepeer/core/actions';
import '../../dist/useInternalQuery-9e9dd997.esm.js';
import '@tanstack/react-query';
import '../../dist/client-c79d9b6b.esm.js';
import '@livepeer/core/client';
import '@tanstack/query-async-storage-persister';
import '@tanstack/react-query-persist-client';
import '../../dist/LivepeerConfig-bc769187.esm.js';
import 'react/jsx-runtime';
import 'use-sync-external-store/shim/with-selector.js';

const useBaseSlider = props => {
  const [localX, setLocalX] = React.useState(null);
  const {
    onChange,
    thumbIcon,
    defaultThumbIcon,
    sliderWidth,
    ariaName,
    isActive,
    leftCss,
    middleCss,
    rightCss,
    thumbCss
  } = props;
  const isActiveOrDragging = isActive || localX !== null;
  const onUpdate = React.useCallback(async (locationX, isComplete) => {
    if (sliderWidth) {
      const newValue = locationX / sliderWidth;
      const newBoundedValue = Math.min(Math.max(0, newValue), 1);
      if (isComplete) {
        await onChange?.(newBoundedValue);
        setLocalX(null);
      } else {
        setLocalX(newBoundedValue);
      }
    }
  }, [onChange, sliderWidth]);
  const {
    value,
    middleValue
  } = React.useMemo(() => {
    const value = localX !== null ? localX : !isNaN(props.value) ? props.value : 0;
    const middleValue = localX !== null ? 0 : props.secondaryValue && !isNaN(props.value) && !isNaN(props.secondaryValue) ? props.secondaryValue - props.value : 0;
    return {
      value,
      middleValue: middleValue > 0 ? middleValue : 0
    };
  }, [localX, props.value, props.secondaryValue]);
  const thumbProps = React.useMemo(() => ({
    css: {
      ...thumbCss,
      zIndex: 1
    },
    size: isActiveOrDragging ? 'active' : 'default'
  }), [thumbCss, isActiveOrDragging]);
  const handle = useMemoizedIcon(thumbIcon, /*#__PURE__*/React.cloneElement(defaultThumbIcon, thumbProps));
  const rightValue = React.useMemo(() => 1 - (value + middleValue), [value, middleValue]);
  const valueRounded = React.useMemo(() => Math.round(value * 100), [value]);
  return {
    title: `${valueRounded}% ${ariaName}`,
    value: valueRounded,
    active: isActiveOrDragging,
    handle,
    sliderProps: {
      onUpdate
    },
    sliderLeftTrackProps: {
      shown: value > 0.001,
      rounded: value === 1 && !isActiveOrDragging ? 'full' : 'left',
      css: {
        ...leftCss,
        flex: value
      }
    },
    sliderMiddleTrackProps: {
      shown: (middleValue ?? 0) > 0,
      rounded: middleValue === 1 ? !isActiveOrDragging ? 'full' : 'right' : value <= 0.001 ? 'left' : rightValue === 0 ? 'right' : 'none',
      css: {
        ...middleCss,
        flex: middleValue
      }
    },
    sliderRightTrackProps: {
      shown: (rightValue ?? 0) > 0,
      rounded: value <= 0.001 && !isActiveOrDragging ? 'full' : 'right',
      css: {
        ...rightCss,
        flex: rightValue
      }
    }
  };
};

const useControlsContainer = props => {
  const {
    togglePlay,
    canPlay,
    buffered
  } = props;
  const isLoaded = React.useMemo(() => canPlay || buffered !== 0, [canPlay, buffered]);
  const onPressBackground = React.useCallback(() => {
    if (isLoaded) {
      togglePlay();
    }
  }, [togglePlay, isLoaded]);
  return {
    isLoaded,
    containerProps: {
      onPress: onPressBackground
    }
  };
};

const useFullscreenButton = props => {
  const {
    enterIcon,
    exitIcon,
    onPress,
    fullscreen,
    pictureInPicture,
    requestToggleFullscreen,
    defaultEnterIcon,
    defaultExitIcon,
    ...rest
  } = props;
  const onPressComposed = React.useCallback(async () => {
    await onPress?.();
    await requestToggleFullscreen();
  }, [onPress, requestToggleFullscreen]);
  const _children = useConditionalIcon(fullscreen, exitIcon, defaultExitIcon, enterIcon, defaultEnterIcon);
  const title = React.useMemo(() => fullscreen ? 'Exit full screen (f)' : 'Full screen (f)', [fullscreen]);
  return {
    title,
    buttonProps: pictureInPicture ? null : {
      onPress: onPressComposed,
      children: _children,
      ...rest
    }
  };
};

const usePlayButton = props => {
  const {
    playIcon,
    pauseIcon,
    onPress,
    togglePlay,
    playing,
    defaultPauseIcon,
    defaultPlayIcon,
    ...rest
  } = props;
  const onPressComposed = async () => {
    await onPress?.();
    await togglePlay();
  };
  const _children = useConditionalIcon(playing, pauseIcon, defaultPauseIcon, playIcon, defaultPlayIcon);
  const title = React.useMemo(() => playing ? 'Pause (k)' : 'Play (k)', [playing]);
  return {
    title,
    buttonProps: {
      onPress: onPressComposed,
      children: _children,
      ...rest
    }
  };
};

const useProgress = props => {
  const {
    duration,
    progress,
    requestSeek,
    buffered,
    ...rest
  } = props;
  const [min, max, current] = React.useMemo(() => [0, duration && !isNaN(duration) ? duration : 0, progress && !isNaN(progress) ? progress : 0], [duration, progress]);
  const value = React.useMemo(() => current / (max - min), [min, max, current]);
  const secondaryValue = React.useMemo(() => buffered / (max - min), [min, max, buffered]);
  const onChange = React.useCallback(async value => {
    const newSeek = value * (max - min);
    await props?.onSeek?.(newSeek);
    requestSeek(newSeek);
  }, [max, min, requestSeek, props]);
  const durationMinutes = React.useMemo(() => (duration / 60).toFixed(1), [duration]);
  return {
    title: `progress of ${durationMinutes} minutes`,
    progressProps: {
      onChange,
      value,
      secondaryValue,
      leftCss: {
        backgroundColor: '$progressLeft'
      },
      middleCss: {
        backgroundColor: '$progressMiddle'
      },
      rightCss: {
        backgroundColor: '$progressRight'
      },
      thumbCss: {
        backgroundColor: '$progressThumb'
      },
      ...rest
    }
  };
};

const getFormattedHoursMinutesSeconds = valueInSeconds => {
  if (valueInSeconds !== undefined && valueInSeconds !== null && !isNaN(valueInSeconds) && isFinite(valueInSeconds)) {
    const roundedValue = Math.round(valueInSeconds);
    const hours = Math.floor(roundedValue / 3600);
    const seconds = Math.floor(roundedValue % 60);
    if (hours > 0) {
      const minutes = Math.floor(roundedValue % 3600 / 60);
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    const minutes = Math.floor(roundedValue / 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  return `0:00`;
};

const useTimeDisplay = props => {
  const {
    duration,
    progress,
    live
  } = props;
  const formattedTimeDisplay = React.useMemo(() => getFormattedHoursMinutesSeconds(progress ?? null), [progress]);
  const formattedDuration = React.useMemo(() => getFormattedHoursMinutesSeconds(duration ?? null), [duration]);
  const formattedTime = React.useMemo(() => live ? formattedTimeDisplay : `${formattedTimeDisplay} / ${formattedDuration}`, [formattedTimeDisplay, formattedDuration, live]);
  return {
    title: formattedTime,
    live
  };
};

const useVolume = props => {
  const {
    unmutedIcon,
    mutedIcon,
    onPress,
    showSlider = true,
    defaultUnmutedIcon,
    defaultMutedIcon,
    requestVolume,
    requestToggleMute,
    isVolumeChangeSupported,
    muted,
    ...rest
  } = props;
  const onPressComposed = React.useCallback(async () => {
    await onPress?.();
    requestToggleMute();
  }, [onPress, requestToggleMute]);
  const _children = useConditionalIcon(!muted, unmutedIcon, defaultUnmutedIcon, mutedIcon, defaultMutedIcon);
  const title = React.useMemo(() => muted ? 'Unmute (m)' : 'Mute (m)', [muted]);
  const onChange = React.useCallback(async value => {
    requestVolume(value);
  }, [requestVolume]);
  return {
    title,
    buttonProps: {
      onPress: onPressComposed,
      children: _children,
      ...rest
    },
    progressProps: {
      shown: isVolumeChangeSupported && showSlider,
      onChange,
      leftCss: {
        backgroundColor: '$volumeLeft'
      },
      middleCss: {
        backgroundColor: '$volumeMiddle'
      },
      rightCss: {
        backgroundColor: '$volumeRight'
      },
      thumbCss: {
        backgroundColor: '$volumeThumb'
      }
    }
  };
};

let PlaybackDisplayErrorType;
(function (PlaybackDisplayErrorType) {
  PlaybackDisplayErrorType["OfflineStream"] = "offlineStream";
  PlaybackDisplayErrorType["PrivateStream"] = "privateStream";
})(PlaybackDisplayErrorType || (PlaybackDisplayErrorType = {}));

/**
 * Retrieves the playback info for a playback ID or source URL.
 * Conditionally, automatically imports a source URL from IPFS or Arweave.
 *
 * @param src Source URL for the media.
 * @param playbackId Playback ID of the media.
 */
const usePlaybackInfoOrImport = ({
  decentralizedSrcOrPlaybackId,
  playbackId,
  refetchPlaybackInfoInterval,
  autoUrlUpload,
  onAssetStatusChange
}) => {
  const {
    mutate: importAsset,
    status,
    progress
  } = useCreateAsset(decentralizedSrcOrPlaybackId ? {
    sources: [{
      name: decentralizedSrcOrPlaybackId.id,
      url: decentralizedSrcOrPlaybackId.url
    }]
  } : null);
  React.useEffect(() => {
    if (progress?.[0]) {
      onAssetStatusChange(progress[0]);
    }
  }, [progress, onAssetStatusChange]);
  const {
    data: playbackInfo,
    error: playbackInfoError
  } = usePlaybackInfo({
    // attempt to fetch if the source is from decentralized storage, or a playback ID is provided
    playbackId: decentralizedSrcOrPlaybackId?.id ?? playbackId ?? undefined,
    refetchInterval: info => info ? false : refetchPlaybackInfoInterval
  });
  const playbackInfoErrorCode = React.useMemo(() => playbackInfoError?.code, [playbackInfoError]);

  // trigger an import if the playback info had a 404 error and the asset is an IPFS source
  // also must be enabled
  React.useEffect(() => {
    if (autoUrlUpload && importAsset && status === 'idle' && playbackInfoErrorCode === 404) {
      importAsset();
    }
  }, [autoUrlUpload, playbackInfoErrorCode, importAsset, status]);
  return playbackInfo;
};

const defaultIpfsGateway = 'https://w3s.link';
const defaultArweaveGateway = 'https://arweave.net';
const useSourceMimeTyped = ({
  src,
  playbackId,
  jwt,
  refetchPlaybackInfoInterval,
  autoUrlUpload = {
    fallback: true
  }
}) => {
  const [uploadStatus, setUploadStatus] = React.useState(null);
  const onAssetStatusChange = React.useCallback(status => {
    setUploadStatus(status);
  }, [setUploadStatus]);

  // check if the src or playbackId are decentralized storage sources (does not handle src arrays)
  const decentralizedSrcOrPlaybackId = React.useMemo(() => playbackId ? parseCid(playbackId) ?? parseArweaveTxId(playbackId) : !Array.isArray(src) ? parseCid(src) ?? parseArweaveTxId(src) : null, [playbackId, src]);
  const playbackInfo = usePlaybackInfoOrImport({
    decentralizedSrcOrPlaybackId,
    playbackId,
    refetchPlaybackInfoInterval,
    autoUrlUpload,
    onAssetStatusChange
  });
  const [playbackUrls, setPlaybackUrls] = React.useState([]);
  React.useEffect(() => {
    const playbackInfoSources = playbackInfo?.meta?.source?.map(s => s?.url)?.filter(s => s);
    if (playbackInfoSources) {
      setPlaybackUrls(playbackInfoSources);
    }
  }, [playbackInfo]);
  const dStoragePlaybackUrl = React.useMemo(() => {
    // if the player is auto uploading, we do not play back the detected input file unless specified
    // e.g. https://arweave.net/84KylA52FVGLxyvLADn1Pm8Q3kt8JJM74B87MeoBt2w/400019.mp4
    if (decentralizedSrcOrPlaybackId && autoUrlUpload && typeof autoUrlUpload !== 'boolean') {
      if (decentralizedSrcOrPlaybackId.url.startsWith('ar://')) {
        const {
          host
        } = new URL(autoUrlUpload.arweaveGateway ?? defaultArweaveGateway);
        const src = {
          type: 'video',
          mime: 'video/mp4',
          src: `https://${host}/${decentralizedSrcOrPlaybackId.id}`
        };
        return src;
      } else if (decentralizedSrcOrPlaybackId.url.startsWith('ipfs://')) {
        const {
          host
        } = new URL(autoUrlUpload.ipfsGateway ?? defaultIpfsGateway);
        const src = {
          type: 'video',
          mime: 'video/mp4',
          src: `https://${host}/ipfs/${decentralizedSrcOrPlaybackId.id}`
        };
        return src;
      }
    }
    return null;
  }, [autoUrlUpload, decentralizedSrcOrPlaybackId]);
  const sourceMimeTyped = React.useMemo(() => {
    // cast all URLs to an array of strings
    const sources = playbackUrls.length > 0 ? playbackUrls : typeof src === 'string' ? [src] : src;
    if (!sources) {
      return null;
    }
    const authenticatedSources = sources.map(source => {
      // append the JWT to the query params
      if (jwt) {
        const url = new URL(source);
        url.searchParams.append('jwt', jwt);
        return url.toString();
      }
      return source;
    });
    const mediaSourceTypes = authenticatedSources.map(s => typeof s === 'string' ? getMediaSourceType(s) : s).filter(s => s);

    // if there are multiple Hls sources, we take only the first one
    // otherwise we pass all sources to the video or audio player components
    if (mediaSourceTypes.every(s => s.type === 'hls') && mediaSourceTypes?.[0]?.type === 'hls') {
      return mediaSourceTypes[0];
    }

    // we filter by the first source type in the array provided
    const mediaSourceFiltered = mediaSourceTypes?.[0]?.type === 'audio' ? mediaSourceTypes.filter(s => s.type === 'audio') : mediaSourceTypes?.[0]?.type === 'video' ? mediaSourceTypes.filter(s => s.type === 'video') : null;
    return mediaSourceFiltered;
  }, [playbackUrls, src, jwt]);
  const sourceMimeTypedWithFallback = React.useMemo(() => {
    if (!sourceMimeTyped && dStoragePlaybackUrl) {
      return [dStoragePlaybackUrl];
    }
    return sourceMimeTyped;
  }, [sourceMimeTyped, dStoragePlaybackUrl]);
  return {
    source: sourceMimeTypedWithFallback,
    uploadStatus
  };
};

const usePlayer = ({
  autoPlay,
  children,
  controls,
  muted,
  playbackId,
  src,
  theme,
  title,
  poster,
  loop,
  onStreamStatusChange,
  onMetricsError,
  onAccessControlError,
  jwt,
  refetchPlaybackInfoInterval = 5000,
  autoUrlUpload = true,
  showLoadingSpinner = true,
  showUploadingIndicator = true,
  showTitle = true,
  priority,
  aspectRatio = '16to9',
  objectFit = 'contain',
  mediaElementRef
}, {
  _isCurrentlyShown
}) => {
  const [mediaElement, setMediaElement] = React.useState(null);
  const [loaded, setLoaded] = React.useState(false);
  const {
    source,
    uploadStatus
  } = useSourceMimeTyped({
    src,
    playbackId,
    jwt,
    refetchPlaybackInfoInterval,
    autoUrlUpload
  });
  const [isStreamOffline, setIsStreamOffline] = React.useState(false);
  const onStreamStatusChangeCallback = React.useCallback(isLive => {
    setIsStreamOffline(!isLive);
    onStreamStatusChange?.(isLive);
  }, [onStreamStatusChange]);
  const [accessControlError, setAccessControlError] = React.useState();
  const accessControlErrorCallback = React.useCallback(error => {
    setAccessControlError(error);
    onAccessControlError?.(error);
  }, [onAccessControlError]);
  const [playbackDisplayErrorType, setPlaybackDisplayErrorType] = React.useState();
  React.useEffect(() => {
    if (isStreamOffline) {
      setPlaybackDisplayErrorType(PlaybackDisplayErrorType.OfflineStream);
    } else if (accessControlError) {
      setPlaybackDisplayErrorType(PlaybackDisplayErrorType.PrivateStream);
    } else {
      setPlaybackDisplayErrorType(undefined);
    }
  }, [accessControlError, isStreamOffline]);

  // if the source is priority or currently shown on the screen, then load
  React.useEffect(() => {
    if (!loaded && (priority || _isCurrentlyShown)) {
      setLoaded(true);
    }
  }, [priority, _isCurrentlyShown, loaded]);
  const hidePosterOnPlayed = React.useMemo(() => Array.isArray(source) ? source?.[0]?.type !== 'audio' ? true : undefined : undefined, [source]);
  const playerRef = React.useCallback(element => {
    if (element) {
      setMediaElement(element);
      mediaElementRef?.(element);
    }
  }, [mediaElementRef]);
  const loadingText = React.useMemo(() => showUploadingIndicator ? uploadStatus?.phase === 'processing' && isNumber(uploadStatus?.progress) ? `Processing: ${(Number(uploadStatus?.progress) * 100).toFixed(0)}%` : uploadStatus?.phase === 'failed' ? 'Upload Failed' : null : null, [uploadStatus, showUploadingIndicator]);
  return {
    mediaElement,
    source: loaded ? source : null,
    uploadStatus,
    playerProps: {
      ref: playerRef,
      autoPlay,
      muted: autoPlay ? true : muted,
      poster: poster,
      loop: loop,
      objectFit: objectFit,
      options: controls
    },
    controlsContainerProps: {
      hidePosterOnPlayed,
      showLoadingSpinner,
      loadingText,
      showUploadingIndicator,
      playbackDisplayErrorType
    },
    props: {
      autoPlay,
      children,
      controls,
      playbackId,
      src,
      theme,
      title,
      poster,
      loop,
      onStreamStatusChange: onStreamStatusChangeCallback,
      onMetricsError,
      onAccessControlError: accessControlErrorCallback,
      jwt,
      refetchPlaybackInfoInterval,
      autoUrlUpload,
      showTitle,
      aspectRatio,
      objectFit
    }
  };
};

export { PlaybackDisplayErrorType, useBaseSlider, useControlsContainer, useFullscreenButton, usePlayButton, usePlayer, useProgress, useTimeDisplay, useVolume };
