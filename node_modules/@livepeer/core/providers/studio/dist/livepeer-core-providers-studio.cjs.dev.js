'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tus = require('tus-js-client');
var fetch = require('cross-fetch');
var errors_dist_livepeerCoreErrors = require('../../../errors/dist/livepeer-core-errors.cjs.dev.js');
var provider = require('../../../dist/provider-838e9dd9.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var tus__namespace = /*#__PURE__*/_interopNamespace(tus);
var fetch__default = /*#__PURE__*/_interopDefault(fetch);

const core = `@livepeer/core@1.1.0`;
const react = `@livepeer/react-native@2.1.0`;
const reactNative = `@livepeer/react@1.1.0`;

class BaseLivepeerProvider {
  /** Provider base config */

  /** Data fetching library */

  constructor(config) {
    this._fetch = fetch__default["default"];
    this._config = config;
  }
  getConfig() {
    return this._config;
  }
  async _get(url, options) {
    const response = await this._fetch(`${this._config.baseUrl}${url}`, {
      method: 'GET',
      ...options,
      headers: {
        ...options?.headers,
        'x-core-sdk-version': core,
        'x-react-sdk-version': react,
        'x-react-native-sdk-version': reactNative
      }
    });
    if (!response.ok) {
      throw new errors_dist_livepeerCoreErrors.HttpError(response.status, `Provider failed to get object from ${this._config.baseUrl}${url}`, await response.json());
    }
    return response.json();
  }
  async _create(url, options) {
    const response = await this._fetch(`${this._config.baseUrl}${url}`, {
      method: 'POST',
      ...options,
      ...(options?.json ? {
        body: JSON.stringify(options.json)
      } : {}),
      headers: {
        ...(options?.json ? {
          'content-type': 'application/json'
        } : {}),
        ...options?.headers,
        'x-core-sdk-version': core,
        'x-react-sdk-version': react,
        'x-react-native-sdk-version': reactNative
      }
    });
    if (!response.ok) {
      throw new errors_dist_livepeerCoreErrors.HttpError(response.status, 'Provider failed to create object', await response.json());
    }
    return response.json();
  }
  async _update(url, options) {
    const response = await this._fetch(`${this._config.baseUrl}${url}`, {
      method: 'PATCH',
      ...options,
      ...(options?.json ? {
        body: JSON.stringify(options.json)
      } : {}),
      headers: {
        ...(options?.json ? {
          'content-type': 'application/json'
        } : {}),
        ...options?.headers,
        'x-core-sdk-version': core,
        'x-react-sdk-version': react,
        'x-react-native-sdk-version': reactNative
      }
    });
    if (!response.ok) {
      throw new errors_dist_livepeerCoreErrors.HttpError(response.status, 'Provider failed to update object', await response.json());
    }
  }
}

class StudioLivepeerProvider extends BaseLivepeerProvider {
  constructor(config) {
    super(config);
    this._defaultHeaders = config.apiKey ? {
      Authorization: `Bearer ${config.apiKey}`
    } : {};
  }
  async createStream(args) {
    const studioStream = await this._create('/stream', {
      json: args,
      headers: this._defaultHeaders
    });
    return this._mapToStream(studioStream);
  }
  async updateStream(args) {
    const streamId = typeof args === 'string' ? args : args.streamId;
    await this._update(`/stream/${streamId}`, {
      json: {
        ...(typeof args?.record !== 'undefined' ? {
          record: Boolean(args.record)
        } : {}),
        ...(typeof args?.suspend !== 'undefined' ? {
          suspended: Boolean(args.suspend)
        } : {}),
        ...(typeof args?.multistream?.targets !== 'undefined' ? {
          multistream: {
            targets: args.multistream.targets.map(t => typeof t.id === 'undefined' || 'url' in (t.spec ?? {}) ? {
              ...t,
              id: undefined
            } : {
              ...t,
              spec: undefined
            })
          }
        } : {}),
        ...(typeof args?.playbackPolicy?.type !== 'undefined' ? {
          playbackPolicy: {
            type: args.playbackPolicy.type
          }
        } : {})
      },
      headers: this._defaultHeaders
    });
    return this.getStream(streamId);
  }
  async getStream(args) {
    const studioStream = await this._get(`/stream/${typeof args === 'string' ? args : args.streamId}`, {
      headers: this._defaultHeaders
    });
    return this._mapToStream(studioStream);
  }
  async getStreamSession(args) {
    const studioStreamSession = await this._get(`/session/${typeof args === 'string' ? args : args.streamSessionId}`, {
      headers: this._defaultHeaders
    });
    return studioStreamSession;
  }
  async getStreamSessions(args) {
    const studioStreamSessions = await this._get(`/stream/${typeof args === 'string' ? args : args.streamId}/sessions`, {
      headers: this._defaultHeaders
    });
    return studioStreamSessions;
  }
  async createAsset(args) {
    const {
      sources,
      onProgress,
      noWait
    } = args;
    let progress = sources.map(source => ({
      name: source.name,
      progress: 0,
      phase: source?.url ? 'waiting' : 'uploading'
    }));

    // upload all assets and do not throw for failed
    const pendingAssetIds = await Promise.allSettled(sources.map(async (source, index) => {
      if (source.url) {
        const createdAsset = await this._create('/asset/upload/url', {
          json: {
            name: source.name,
            url: source.url
          },
          headers: this._defaultHeaders
        });
        return createdAsset?.asset?.id;
      } else {
        const uploadReq = await this._create('/asset/request-upload', {
          json: {
            name: source.name
          },
          headers: this._defaultHeaders
        });
        const {
          tusEndpoint,
          asset: {
            id: assetId
          }
        } = uploadReq;
        await new Promise((resolve, reject) => {
          const upload = new tus__namespace.Upload(source.file, {
            endpoint: tusEndpoint,
            metadata: {
              id: assetId
            },
            ...(source instanceof File ? null : {
              chunkSize: 5 * 1024 * 1024
            }),
            // fingerprint: function (file: File & { exif?: any }) {
            //   return fingerprint(file);
            // },
            onError: error => {
              console.log('Failed because: ', error);
            },
            // TODO add configurable url storage for nodejs
            onProgress(bytesSent, bytesTotal) {
              const progressPercent = bytesSent / bytesTotal;
              const status = {
                name: source.name,
                progress: progressPercent,
                phase: 'uploading'
              };
              const newSources = [...progress];
              newSources[index] = status;
              progress = newSources;
              onProgress?.(progress);
            },
            onSuccess() {
              resolve();
            }
          });
          upload.findPreviousUploads().then(previousUploads => {
            if (previousUploads?.length > 0 && previousUploads[0]) {
              upload.resumeFromPreviousUpload(previousUploads[0]);
            }
            upload.start();
          }).catch(reject);
        });
        return assetId;
      }
    }));
    if (noWait) {
      return Promise.all(pendingAssetIds.map(async assetIdResult => {
        if (assetIdResult.status === 'rejected') {
          throw assetIdResult.reason;
        }
        return this.getAsset(assetIdResult.value);
      }));
    }
    const MAX_ERROR_COUNT = 5;

    // wait for all assets to complete uploading before returning
    const assets = await Promise.allSettled(pendingAssetIds.map(async (assetIdResult, index) => {
      if (assetIdResult.status === 'rejected') {
        throw assetIdResult.reason;
      }
      let asset = null;
      let errorCount = 0;
      while (asset?.status?.phase !== 'ready' && asset?.status?.phase !== 'failed') {
        try {
          // wait w/ random jitter
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 4000));
          asset = await this.getAsset(assetIdResult.value);
          if (typeof asset.status?.phase !== 'undefined') {
            const status = {
              name: asset.name,
              progress: asset.status.progress ?? 0,
              phase: asset.status.phase
            };
            const newSources = [...progress];
            newSources[index] = status;
            progress = newSources;
            onProgress?.(progress);
          }
        } catch (e) {
          // hits the max error limit and throws the error
          if (errorCount > MAX_ERROR_COUNT) {
            throw e;
          }
          errorCount += 1;
        }
      }
      const status = {
        name: asset.name,
        progress: 1,
        phase: asset.status.phase
      };
      const newSources = [...progress];
      newSources[index] = status;
      progress = newSources;
      onProgress?.(progress);
      return asset;
    }));
    const mappedAssets = [...assets.map(asset => {
      if (asset.status === 'fulfilled') {
        return asset.value;
      } else {
        throw asset.reason;
      }
    })];
    return mappedAssets;
  }
  async getAsset(args) {
    const studioAsset = await this._get(`/asset/${typeof args === 'string' ? args : args.assetId}`, {
      headers: this._defaultHeaders
    });
    return studioAsset;
  }
  async updateAsset(args) {
    const {
      assetId,
      name,
      storage
    } = args;
    await this._update(`/asset/${assetId}`, {
      json: {
        name: typeof name !== 'undefined' ? String(name) : undefined,
        storage: storage?.ipfs ? {
          ipfs: {
            spec: {
              nftMetadata: storage?.metadata ?? {},
              nftMetadataTemplate: storage?.metadataTemplate ?? 'player'
            }
          }
        } : undefined
      },
      headers: this._defaultHeaders
    });
    return this.getAsset({
      assetId
    });
  }
  _getRtmpIngestUrl(streamKey) {
    return `rtmp://rtmp.livepeer.com/live/${streamKey}`;
  }
  async getPlaybackInfo(args) {
    const playbackId = typeof args === 'string' ? args : args.playbackId;
    const urlEncodedPlaybackId = encodeURIComponent(playbackId);
    const studioPlaybackInfo = await this._get(`/playback/${urlEncodedPlaybackId}`, {
      headers: this._defaultHeaders
    });
    return this._mapToPlaybackInfo(studioPlaybackInfo);
  }
  _getPlaybackUrl(playbackId) {
    return `https://livepeercdn.com/hls/${playbackId}/index.m3u8`;
  }
  async getAssetMetrics(args) {
    const assetId = typeof args === 'string' ? args : args.assetId;
    const studioViewsMetrics = await this._get(`/data/views/${assetId}/total`, {
      headers: this._defaultHeaders
    });
    return this._mapToViewsMetrics(studioViewsMetrics);
  }
  async _mapToStream(studioStream) {
    return {
      ...studioStream,
      multistream: await this._mapToMultistream(studioStream.multistream),
      rtmpIngestUrl: this._getRtmpIngestUrl(studioStream.streamKey),
      playbackUrl: this._getPlaybackUrl(studioStream.playbackId)
    };
  }
  async _mapToMultistream(studioMultistream) {
    if (!studioMultistream?.targets) {
      return undefined;
    }
    const fetchTargets = studioMultistream.targets.map(async t => {
      const {
        name
      } = await this._get(`/multistream/target/${t.id}`, {
        headers: this._defaultHeaders
      });
      return {
        ...t,
        spec: {
          name
        }
      };
    });
    return {
      targets: await Promise.all(fetchTargets)
    };
  }
  _mapToPlaybackInfo(studioPlaybackInfo) {
    return {
      type: studioPlaybackInfo?.['type'],
      meta: {
        live: studioPlaybackInfo?.['meta']?.['live'] ? Boolean(studioPlaybackInfo?.['meta']['live']) : false,
        source: studioPlaybackInfo?.['meta']?.['source']?.map(source => ({
          hrn: source?.['hrn'],
          type: source?.['type'],
          url: source?.['url']
        }))
      }
    };
  }
  _mapToViewsMetrics(studioMetrics) {
    return {
      type: 'ViewsMetrics',
      metrics: studioMetrics
    };
  }
}
function studioProvider(config) {
  return () => new StudioLivepeerProvider({
    ...provider.defaultStudioConfig,
    ...config
  });
}

exports.StudioLivepeerProvider = StudioLivepeerProvider;
exports.studioProvider = studioProvider;
