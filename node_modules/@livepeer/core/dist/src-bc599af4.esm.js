import { persist } from 'zustand/middleware';
import create from 'zustand/vanilla';

const DEFAULT_SEEK_TIME = 5000; // milliseconds which the media will skip when seeking with arrows/buttons
const DEFAULT_VOLUME_LEVEL = 0.2; // 0-1 for how loud the audio is

const DEFAULT_AUTOHIDE_TIME = 3000; // milliseconds to wait before hiding controls

const getFilteredNaN = value => value && !isNaN(value) && isFinite(value) ? value : 0;
const getBoundedSeek = (seek, duration) => Math.min(Math.max(0, getFilteredNaN(seek)),
// seek to near the end
getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0);
const getBoundedVolume = volume => Math.min(Math.max(0, getFilteredNaN(volume)), 1);
const createControllerStore = ({
  element,
  device,
  storage,
  opts
}) => {
  const store = create(persist((set, get) => ({
    _element: element,
    canPlay: false,
    hidden: false,
    live: false,
    hasPlayed: false,
    playing: false,
    fullscreen: false,
    pictureInPicture: false,
    waiting: false,
    stalled: false,
    loading: false,
    playbackRate: 1,
    device,
    progress: 0,
    duration: 0,
    buffered: 0,
    volume: getBoundedVolume(opts?.defaultVolume ?? DEFAULT_VOLUME_LEVEL),
    muted: true,
    isVolumeChangeSupported: false,
    _lastInteraction: Date.now(),
    _requestedRangeToSeekTo: 0,
    _requestedFullscreenLastTime: Date.now(),
    _requestedPictureInPictureLastTime: Date.now(),
    _requestedPlayPauseLastTime: Date.now(),
    setHidden: hidden => set(({
      playing
    }) => ({
      hidden: playing ? hidden : false
    })),
    _updateLastInteraction: () => set(() => ({
      _lastInteraction: Date.now()
    })),
    onCanPlay: () => set(() => ({
      canPlay: true,
      loading: false
    })),
    onPlay: () => set(() => ({
      playing: true,
      hasPlayed: true,
      stalled: false,
      waiting: false
    })),
    onPause: () => set(() => ({
      playing: false,
      hidden: false,
      // TODO check if these should be getting set when pause event is fired (this was pulled from metrics)
      stalled: false,
      waiting: false
    })),
    togglePlay: force => {
      const {
        hidden,
        setHidden,
        device
      } = store.getState();
      if (!force && hidden && device.isMobile) {
        setHidden(false);
      } else {
        set(() => ({
          _requestedPlayPauseLastTime: Date.now(),
          _lastInteraction: Date.now()
        }));
      }
    },
    onProgress: time => set(() => ({
      progress: getFilteredNaN(time)
    })),
    requestSeek: time => set(({
      duration
    }) => ({
      _requestedRangeToSeekTo: getBoundedSeek(time, duration),
      progress: getBoundedSeek(time, duration)
    })),
    onDurationChange: duration => set(({
      live
    }) => ({
      duration,
      live: duration === Number.POSITIVE_INFINITY ? true : live
    })),
    _updateBuffered: buffered => set(() => ({
      buffered
    })),
    _requestSeekDiff: difference => set(({
      progress,
      duration
    }) => ({
      _requestedRangeToSeekTo: getBoundedSeek(getFilteredNaN(progress) + difference / 1000, duration)
    })),
    requestSeekBack: (difference = DEFAULT_SEEK_TIME) => get()._requestSeekDiff(-difference),
    requestSeekForward: (difference = DEFAULT_SEEK_TIME) => get()._requestSeekDiff(difference),
    setSize: size => set(() => ({
      size
    })),
    setWaiting: waiting => set(() => ({
      waiting
    })),
    setError: error => set(() => ({
      error
    })),
    setStalled: stalled => set(() => ({
      stalled
    })),
    setLoading: loading => set(() => ({
      loading
    })),
    setFullscreen: fullscreen => set(() => ({
      fullscreen
    })),
    requestToggleFullscreen: () => set(() => ({
      _requestedFullscreenLastTime: Date.now()
    })),
    setPictureInPicture: pictureInPicture => set(() => ({
      pictureInPicture
    })),
    requestTogglePictureInPicture: () => set(() => ({
      _requestedPictureInPictureLastTime: Date.now()
    })),
    setLive: live => set(() => ({
      live
    })),
    requestVolume: newVolume => set(({
      volume
    }) => ({
      volume: newVolume === 0 ? volume : getBoundedVolume(newVolume),
      muted: newVolume === 0
    })),
    _setVolume: newVolume => set(() => ({
      volume: getBoundedVolume(newVolume)
    })),
    requestToggleMute: () => set(({
      muted
    }) => ({
      muted: !muted
    })),
    setIsVolumeChangeSupported: supported => set(() => ({
      isVolumeChangeSupported: supported
    }))
  }), {
    name: 'livepeer-player',
    version: 1,
    // since these values are persisted across media, only persist volume and playbackRate
    partialize: ({
      volume,
      playbackRate
    }) => ({
      volume,
      playbackRate
    }),
    getStorage: () => storage
  }));
  return store;
};

const getMimeType = ending => {
  for (const value of Object.keys(mime)) {
    if (mime[value]?.some(v => v === ending)) {
      return value;
    }
  }
  return null;
};
const mime = {
  'application/mp4': ['mp4s', 'm4p'],
  'application/ogg': ['ogx'],
  'application/vnd.apple.mpegurl': ['m3u8'],
  'audio/3gpp': ['*3gpp'],
  'audio/adpcm': ['adp'],
  'audio/amr': ['amr'],
  'audio/basic': ['au', 'snd'],
  'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
  'audio/mobile-xmf': ['mxmf'],
  'audio/mp3': ['*mp3'],
  'audio/mp4': ['m4a', 'mp4a'],
  'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
  'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
  'audio/s3m': ['s3m'],
  'audio/silk': ['sil'],
  'audio/vnd.dece.audio': ['uva', 'uvva'],
  'audio/vnd.digital-winds': ['eol'],
  'audio/vnd.dra': ['dra'],
  'audio/vnd.dts.hd': ['dtshd'],
  'audio/vnd.dts': ['dts'],
  'audio/vnd.lucent.voice': ['lvp'],
  'audio/vnd.ms-playready.media.pya': ['pya'],
  'audio/vnd.nuera.ecelp4800': ['ecelp4800'],
  'audio/vnd.nuera.ecelp7470': ['ecelp7470'],
  'audio/vnd.nuera.ecelp9600': ['ecelp9600'],
  'audio/vnd.rip': ['rip'],
  'audio/wav': ['wav'],
  'audio/wave': ['*wav'],
  'audio/webm': ['weba'],
  'audio/x-aac': ['aac'],
  'audio/x-aiff': ['aif', 'aiff', 'aifc'],
  'audio/x-caf': ['caf'],
  'audio/x-flac': ['flac'],
  'audio/x-m4a': ['*m4a'],
  'audio/x-matroska': ['mka'],
  'audio/x-mpegurl': ['m3u'],
  'audio/x-ms-wax': ['wax'],
  'audio/x-ms-wma': ['wma'],
  'audio/x-pn-realaudio-plugin': ['rmp'],
  'audio/x-pn-realaudio': ['ram', 'ra'],
  'audio/x-realaudio': ['*ra'],
  'audio/x-wav': ['*wav'],
  'audio/xm': ['xm'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['*jpm', 'jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/vnd.dece.hd': ['uvh', 'uvvh'],
  'video/vnd.dece.mobile': ['uvm', 'uvvm'],
  'video/vnd.dece.pd': ['uvp', 'uvvp'],
  'video/vnd.dece.sd': ['uvs', 'uvvs'],
  'video/vnd.dece.video': ['uvv', 'uvvv'],
  'video/vnd.dvb.file': ['dvb'],
  'video/vnd.fvt': ['fvt'],
  'video/vnd.mpegurl': ['mxu', 'm4u'],
  'video/vnd.ms-playready.media.pyv': ['pyv'],
  'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],
  'video/vnd.vivo': ['viv'],
  'video/webm': ['webm'],
  'video/x-f4v': ['f4v'],
  'video/x-fli': ['fli'],
  'video/x-flv': ['flv'],
  'video/x-m4v': ['m4v'],
  'video/x-matroska': ['mkv', 'mk3d', 'mks'],
  'video/x-mng': ['mng'],
  'video/x-ms-asf': ['asf', 'asx'],
  'video/x-ms-vob': ['vob'],
  'video/x-ms-wm': ['wm'],
  'video/x-ms-wmv': ['wmv'],
  'video/x-ms-wmx': ['wmx'],
  'video/x-ms-wvx': ['wvx'],
  'video/x-msvideo': ['avi'],
  'video/x-sgi-movie': ['movie'],
  'video/x-smv': ['smv']
};

const audioExtensions = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
const videoExtensions = /\.(mp4|ogv|webm|mov|m4v|avi|m3u8)($|\?)/i;
const hlsExtensions = /\.(m3u8)($|\?)/i;
const getMediaSourceType = src => {
  return hlsExtensions.test(src) ? {
    type: 'hls',
    src: src,
    mime: getMimeType(hlsExtensions.exec(src)?.[1] ?? '')
  } : videoExtensions.test(src) ? {
    type: 'video',
    src: src,
    mime: getMimeType(videoExtensions.exec(src)?.[1] ?? '')
  } : audioExtensions.test(src) ? {
    type: 'audio',
    src: src,
    mime: getMimeType(audioExtensions.exec(src)?.[1] ?? '')
  } : null;
};

export { DEFAULT_AUTOHIDE_TIME as D, DEFAULT_VOLUME_LEVEL as a, createControllerStore as c, getMediaSourceType as g };
